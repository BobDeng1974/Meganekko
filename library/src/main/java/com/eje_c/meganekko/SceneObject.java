/* 
 * Copyright 2015 eje inc.
 * Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.eje_c.meganekko;

import com.eje_c.meganekko.Material.ShaderType;
import com.eje_c.meganekko.RenderData.RenderMaskBit;
import com.eje_c.meganekko.event.FrameListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * One of the key Meganekko classes: a scene object.
 * <p/>
 * Every scene object has a {@linkplain #getTransform() location}, and can have
 * {@linkplain #children() children}. An invisible scene object can be used to
 * move a set of scene as a unit, preserving their relative geometry. Invisible
 * scene objects don't need any {@linkplain SceneObject#getRenderData() render
 * data.}
 * <p/>
 * <p/>
 * Visible scene objects must have render data
 * {@linkplain SceneObject#attachRenderData(RenderData) attached.} Each
 * {@link RenderData} has a {@link Mesh GL mesh} that defines its geometry, and
 * a {@link Material} that defines its surface.
 */
public class SceneObject extends HybridObject implements FrameListener {

    private static final MaterialShaderId STANDARD_SHADER = ShaderType.OES.ID;
    private final List<SceneObject> mChildren = new ArrayList<SceneObject>();
    private int mId;
    private String mName;
    private Transform mTransform;
    private RenderData mRenderData;
    private SceneObject mParent;
    private float mOpacity = 1.0f;
    private boolean mVisible = true;

    /**
     * Constructs an empty scene object with a default {@link Transform
     * transform}.
     *
     * @param vrContext current {@link VrContext}
     */
    public SceneObject(VrContext vrContext) {
        super(vrContext);
        attachTransform(new Transform(vrContext));
    }

    /**
     * Constructs a scene object with an arbitrarily complex mesh.
     *
     * @param vrContext current {@link VrContext}
     * @param mesh      a {@link Mesh} - usually generated by one of the
     *                  {@link VrContext#loadMesh(AndroidResource)} methods, or
     *                  {@link VrContext#createQuad(float, float)}
     */
    public SceneObject(VrContext vrContext, Mesh mesh) {
        this(vrContext);
        RenderData renderData = new RenderData(vrContext);
        attachRenderData(renderData);
        renderData.setMesh(mesh);
    }

    /**
     * Constructs a rectangular scene object, whose geometry is completely
     * specified by the width and height.
     *
     * @param vrContext current {@link VrContext}
     * @param width     the scene object's width
     * @param height    the scene object's height
     */
    public SceneObject(VrContext vrContext, float width, float height) {
        this(vrContext, vrContext.createQuad(width, height));
    }

    @Override
    protected native long initNativeInstance();

    /**
     * Get the (optional) ID of the object.
     *
     * @return The ID of the object. If no name has been assigned, return 0.
     */
    public int getId() {
        return mId;
    }

    /**
     * Set the (optional) ID of the object.
     * <p/>
     * Scene object IDs are not needed: they are only for the application's
     * convenience.
     *
     * @param id ID of the object.
     */
    public void setId(int id) {
        this.mId = id;
    }

    /**
     * Get the (optional) name of the object.
     *
     * @return The name of the object. If no name has been assigned, the
     * returned string will be empty.
     */
    public String getName() {
        return mName;
    }

    /**
     * Set the (optional) name of the object.
     * <p/>
     * Scene object names are not needed: they are only for the application's
     * convenience.
     *
     * @param name Name of the object.
     */
    public void setName(String name) {
        mName = name;
    }

    /**
     * Replace the current {@link Transform transform}
     *
     * @param transform New transform.
     */
    void attachTransform(Transform transform) {
        mTransform = transform;
        attachTransform(getNative(), transform.getNative());
    }

    /**
     * Remove the object's {@link Transform transform}. After this call, the
     * object will have no transformations associated with it.
     */
    void detachTransform() {
        mTransform = null;
        detachTransform(getNative());
    }

    /**
     * Get the {@link Transform}.
     * <p/>
     * A {@link Transform} encapsulates a 4x4 matrix that specifies how to
     * render the {@linkplain Mesh GL mesh:} transform methods let you move,
     * rotate, and scale your scene object.
     *
     * @return The current {@link Transform transform}. If no transform is
     * currently attached to the object, returns {@code null}.
     */
    public Transform getTransform() {
        return mTransform;
    }

    /**
     * Attach {@linkplain RenderData rendering data} to the object.
     * <p/>
     * If other rendering data is currently attached, it is replaced with the
     * new data. {@link RenderData} contains the GL mesh, the texture, the
     * shader id, and various shader constants.
     *
     * @param renderData New rendering data.
     */
    public void attachRenderData(RenderData renderData) {
        mRenderData = renderData;
        renderData.setOwnerObject(this);
        attachRenderData(getNative(), renderData.getNative());
    }

    /**
     * Detach the object's current {@linkplain RenderData rendering data}.
     * <p/>
     * An object with no {@link RenderData} is not visible.
     */
    public void detachRenderData() {
        if (mRenderData != null) {
            mRenderData.setOwnerObject(null);
        }
        mRenderData = null;
        detachRenderData(getNative());
    }

    /**
     * Get the current {@link RenderData}.
     *
     * @return The current {@link RenderData rendering data}. If no rendering
     * data is currently attached to the object, returns {@code null}.
     */
    public RenderData getRenderData() {
        return mRenderData;
    }

    /**
     * Get the {@linkplain SceneObject parent object.}
     * <p/>
     * If the object has been {@link #addChildObject(SceneObject) added as a
     * child} to another {@link SceneObject}, returns that object. Otherwise,
     * returns {@code null}.
     *
     * @return The parent {@link SceneObject} or {@code null}.
     */
    public SceneObject getParent() {
        return mParent;
    }

    /**
     * Add {@code child} as a child of this object.
     *
     * @param child {@link SceneObject Object} to add as a child of this object.
     */
    public void addChildObject(SceneObject child) {
        mChildren.add(child);
        child.mParent = this;
        addChildObject(getNative(), child.getNative());
    }

    /**
     * Remove {@code child} as a child of this object.
     *
     * @param child {@link SceneObject Object} to remove as a child of this
     *              object.
     */
    public void removeChildObject(SceneObject child) {
        mChildren.remove(child);
        child.mParent = null;
        removeChildObject(getNative(), child.getNative());
    }

    /**
     * Check if {@code otherObject} is colliding with this object.
     *
     * @param otherObject {@link SceneObject Object} to check for collision with this
     *                    object.
     * @return {@code true) if objects collide, {@code false} otherwise
     */
    public boolean isColliding(SceneObject otherObject) {
        return isColliding(getNative(),
                otherObject.getNative());
    }

    /**
     * Sets the range of distances from the camera where this object will be
     * shown.
     *
     * @param minRange The closest distance to the camera in which this object should
     *                 be shown. This should be a positive number between 0 and
     *                 Float.MAX_VALUE.
     * @param maxRange The farthest distance to the camera in which this object
     *                 should be shown. This should be a positive number between 0
     *                 and Float.MAX_VALUE.
     */
    public void setLODRange(float minRange, float maxRange) {
        if (minRange < 0 || maxRange < 0) {
            throw new IllegalArgumentException(
                    "minRange and maxRange must be between 0 and Float.MAX_VALUE");
        }
        if (minRange > maxRange) {
            throw new IllegalArgumentException(
                    "minRange should not be greater than maxRange");
        }
        setLODRange(getNative(), minRange, maxRange);
    }

    /**
     * Get the minimum distance from the camera in which to show this object.
     *
     * @return the minimum distance from the camera in which to show this
     * object. Default value is 0.
     */
    public float getLODMinRange() {
        return getLODMinRange(getNative());
    }

    /**
     * Get the maximum distance from the camera in which to show this object.
     *
     * @return the maximum distance from the camera in which to show this
     * object. Default value is Float.MAX_VALUE.
     */
    public float getLODMaxRange() {
        return getLODMaxRange(getNative());
    }

    /**
     * Get the number of child objects.
     *
     * @return Number of {@link SceneObject objects} added as children of this
     * object.
     */
    public int getChildrenCount() {
        return mChildren.size();
    }

    /**
     * Get the child object at {@code index}.
     *
     * @param index Position of the child to get.
     * @return {@link SceneObject Child object}.
     * @throws {@link java.lang.IndexOutOfBoundsException} if there is no child at
     *                that position.
     */
    public SceneObject getChildByIndex(int index) {
        return mChildren.get(index);
    }

    /**
     * As an alternative to calling {@link #getChildrenCount()} then repeatedly
     * calling {@link #getChildByIndex(int)}, you can
     * <p/>
     * <pre>
     * for (GVRSceneObject child : parent.children()) {
     * }
     * </pre>
     *
     * @return An {@link Iterable}, so you can use Java's enhanced for loop.
     * This {@code Iterable} gives you an {@link Iterator} that does not
     * support {@link Iterator#remove()}.
     * <p/>
     * At some point, this might actually return a
     * {@code List<GVRSceneObject>}, but that would require either
     * creating an immutable copy or writing a lot of code to support
     * methods like {@link List#addAll(java.util.Collection)} and
     * {@link List#clear()} - for now, we just create a very
     * light-weight class that only supports iteration.
     */
    public Iterable<SceneObject> children() {
        return new Children(this);
    }

    /**
     * Get all the children, in a single list.
     *
     * @return An un-modifiable list of this object's children.
     */
    public List<SceneObject> getChildren() {
        return Collections.unmodifiableList(mChildren);
    }

    /**
     * The internal list - do not make any changes!
     */
    List<SceneObject> rawGetChildren() {
        return mChildren;
    }

    /**
     * Add {@code childComponent} as a child of this object (owner object of the
     * component is added as child). Adding a component will increase the
     * {@link SceneObject#getChildrenCount() getChildrenCount()} for this scene object.
     *
     * @param childComponent {@link Component Component} to add as a child of this object.
     */
    public void addChildObject(Component childComponent) {
        if (childComponent.getOwnerObject() != null) {
            addChildObject(childComponent.getOwnerObject());
        }
    }

    /**
     * Remove {@code childComponent} as a child of this object (owner object of
     * the component is removed as child). Removing a component will decrease
     * the {@link SceneObject#getChildrenCount() getChildrenCount()} for this scene object.
     *
     * @param childComponent {@link Component Component} to remove as a child of this
     *                       object.
     */
    public void removeChildObject(Component childComponent) {
        if (childComponent.getOwnerObject() != null) {
            removeChildObject(childComponent.getOwnerObject());
        }
    }

    /**
     * Get visibility set by {@link SceneObject#setVisible(boolean) setVisible()}.
     *
     * @return Visibility of this object.
     */
    public boolean isVisible() {
        return mVisible;
    }

    /**
     * Set visibility of this object. This affects also all children of this
     * object.
     *
     * @param visible
     */
    public void setVisible(boolean visible) {
        this.mVisible = visible;
        updateVisibility();
    }

    /**
     * Get if object is shown to scene.
     *
     * @return Visibility of this object. Even if isVisible() == true, it can
     * return false if this parent.isVisible() == false.
     */
    public boolean isShown() {

        if (!mVisible)
            return mVisible;

        if (getParent() == null)
            return mVisible;

        return mVisible && getParent().isShown();
    }

    private void updateVisibility() {
        RenderData renderData = getRenderData();
        if (renderData != null) {
            boolean visible = isShown();
            renderData.setRenderMask(visible ? RenderMaskBit.Left | RenderMaskBit.Right : 0);
        }

        for (SceneObject child : children()) {
            child.updateVisibility();
        }
    }

    /**
     * Get opacity set by {@link SceneObject#setOpacity(float) setOpacity()}.
     *
     * @return opacity
     */
    public float getOpacity() {
        return mOpacity;
    }

    /**
     * Set opacity of this object. This affects also all children of this
     * object.
     *
     * @param opacity
     */
    public void setOpacity(float opacity) {
        this.mOpacity = opacity;
        updateOpacity();
    }

    private float getInternalOpacity() {
        float parentOpacity = getParent() != null ? getParent().getInternalOpacity() : 1.0f;
        return mOpacity * parentOpacity;
    }

    private void updateOpacity() {
        RenderData renderData = getRenderData();
        if (renderData != null) {
            Material material = renderData.getMaterial();
            if (material != null) {
                float opacity = getInternalOpacity();
                material.setOpacity(opacity);
            }
        }

        for (SceneObject child : children()) {
            child.updateOpacity();
        }
    }

    public SceneObject findObjectById(int id) {
        if (mId == id) {
            return this;
        }

        for (SceneObject child : children()) {
            SceneObject result = child.findObjectById(id);
            if (result != null) {
                return result;
            }
        }

        return null;
    }

    public SceneObject findObjectByName(String name) {
        if (name.equals(getName())) {
            return this;
        }

        for (SceneObject child : children()) {
            SceneObject result = child.findObjectByName(name);
            if (result != null) {
                return result;
            }
        }

        return null;
    }

    /**
     * Called from native thread just before this object will be render. If this
     * method returns false, this object is not rendered.
     *
     * @return If this object should be rendered.
     */
    protected boolean onRender() {
        return true;
    }

    @Override
    public void onEvent(VrFrame vrFrame) {
        for (SceneObject child : children()) {
            child.onEvent(vrFrame);
        }
    }

    private static class Children implements Iterable<SceneObject>,
            Iterator<SceneObject> {

        private final SceneObject object;
        private int index;

        private Children(SceneObject object) {
            this.object = object;
            this.index = 0;
        }

        @Override
        public Iterator<SceneObject> iterator() {
            return this;
        }

        @Override
        public boolean hasNext() {
            return index < object.getChildrenCount();
        }

        @Override
        public SceneObject next() {
            return object.getChildByIndex(index++);
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private static native void attachTransform(long sceneObject, long transform);

    private static native void detachTransform(long sceneObject);

    private static native void attachRenderData(long sceneObject, long renderData);

    private static native void detachRenderData(long sceneObject);

    private static native void attachEyePointeeHolder(long sceneObject, long eyePointeeHolder);

    private static native void detachEyePointeeHolder(long sceneObject);

    private static native void addChildObject(long sceneObject, long child);

    private static native void removeChildObject(long sceneObject, long child);

    private static native boolean isColliding(long sceneObject, long otherObject);

    private static native void setLODRange(long sceneObject, float minRange, float maxRange);

    private static native float getLODMinRange(long sceneObject);

    private static native float getLODMaxRange(long sceneObject);
}
